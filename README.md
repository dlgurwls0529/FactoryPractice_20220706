## 1. 팩토리 메소드 패턴(Factory Method Pattern)

### 1.1. 팩토리 메소드 패턴의 의미
팩토리 메소드 패턴이란, 객체를 생성할 때 구체적으로  
어떤 것을 만들지 정하는 것을 서브클래스에 위임하는 것이다.  
Factory 인터페이스로 객체를 리턴하는 추상 메소드를 선언하고  
ConcreteFactory(서브클래스) 에서 그것을 구현한다.  

상속을 통해 하나의 상위 타입이 있고, 그것에 의존하는 다양한 클래스가 있다고 하자  
예를 들어 배를 만드는 것을 상상해보자  
처음에 하얀배를 만들고 나서, 그것이 잘 되면  
검은 배나, 빨간 배 등 다양한 것들을 만들어야 하게 된다.  
보통 조건(색깔)을 받아서 if 문을 통해 각각을 리턴한다.  

      if(color.equals("white"))
        return WhiteShip();
      else if(color.equals("Red"))
        return RedShip();
        
하지만, 이는 조건이 추가(노란 배)되면 복잡한 if else 를  
수정해야 한다. 이는 객체 지향 원칙 OCP 에 위배된다.  
OCP를 충족시키고 유연한 구조로 개선한 것이 팩토리 메소드 패턴이다.  

### 1.2. 팩토리 메소드 패턴의 장점
이를 통해서 새로운 요구사항이 발생하였을 때, 기존 클래스  
를 수정하는 것이 아니라 새로운 클래스(+팩토리)를  
추가하는 것만으로 처리가 가능해진다.  

### 1.3. 팩토리 메소드 패턴의 단점
하지만, 이 과정에서 각 Product 생성 과정을  
위임하기 위해 많은 수의 서브클래스가 만들어진다는 단점이 있다.  

### 1.4. 팩토리 메소드 패턴 버전 별 구현
이것을 구현하는 방법은 버전마다 다르다.  
그것은 자바 8 에서 추가된 인터페이스 default 메소드와  
자바 9 에서 추가된 인터페이스 private 메소드의 추가로 인해 달라진다.  
두 메소드의 공통점은 모두 인터페이스에 구현체를 만들 수 있다는 점이고  
차이점은 하위 클래스에서 호출이 가능(default), 호출이 불가능(private)가 있다.  
  
8 버전에서는 private 메소드가 없으니  
인터페이스 - 추상클래스(private 메소드 구현) - 구상클래스로 구현한다.  
  
7 버전 이하에서는 default 메소드도 없어서  
인터페이스(전부 추상메서드) - 추상클래스(default, private 전부 구현) - 구상클래스로 구현한다.  
  
9 이상에서는 그냥 추상클래스 역할을 인터페이스가 대신한다. 

### 1.5. 정적 팩토리 메소드(Static Factory Method)
정적 팩토리 메소드란 아래서 언급하듯, 클래스의 인스턴스를 반환하는 정적 메소드이다.  
이 메소드는 특성 클래스에서 조건 분기(if-else)를 통해 여러 클래스를 반환한다.  
      
      <CarFactory.Class>
      public Car createCar(String color) {
            Car car = null;
            if(color.equals("Red")) {
                  car = new RedCar();
            }
            else if(color.equals("Blue")) {
                  car = new BlueCar();
            }
            else {
            
            }
      }

이런 느낌?이다.  

정적 팩토리 메소드의 장점은 다섯 가지 정도가 있다.  
1. 이름을 가질 수 있다.  
인자로 이름을 전달함으로써, 반환 객체의 타입을 예상할 수 있다.  
2. 호출할 때마다 인스턴스를 매번 만들지는 않아도 된다.  
조건 분기에 따라 기존 객체를 재활용해도 되는 상황이면, 그래도 된다.  
3. 다형성을 응용할 수 있다.!!
메소드 반환 타입을 슈퍼클래스, 반환 값을 서브클래스로 하면  
다형성의 장점을 누릴? 수 있다. (그냥 인터페이스 타입으로 받아서 쓰면 되는 것 등..)  
5. 입력 매개변수에 따라 다른 객체를 반환할 수 있다.!!

단점도 있다.
1. 생성자를 private으로 묶어야 해서 정적 팩토리 메소드가 있는  
클래스는 서브클래스를 못만든다.  
2. 다른 정적 메소드와 잘 구분이 안된다.  
그래서 보통 네이밍 컨벤션이 따로 있다.  
3. OCP를 충족하지 않아, 유지보수가 어렵다.  

### 1.6. 정적 팩토리 메소드 vs 팩토리 메소드 패턴  
* 정적 팩토리 메서드 : 단순히 클래스의 인스턴스를 반환하는 정적 메서드이다.  
이 메서드는 특정 클래스에 속해서 조건 분기를 통해 다양한 클래스를 반환한다.  
Effective 자바에서 나오는 것이 이거다.  

* 팩토리 메소드 패턴 : 객체 생성을 위한 인터페이스를 정의하고, 그것을 구현하는 클래스가  
인스턴스화할 클래스를 결정한다. 즉, 객체 생성을 서브클래스에 위임하는 것이다.  
GOF 의 디자인 패턴에 나오는 것이 이거다.

> 보다 유연하게 factory 의 목적을 달성  
(목적 : 새로운 제품군이 만들어지면, 이를 쉽게 반영할 수 있다.)  
하는 것이 GOF 의 팩토리 메소드 패턴(팩토리 인터페이스?)  

### 1.7. 팩토리 메소드 패턴과 의존성 주입
팩토리 메소드 패턴과 함께 이용되는 것이 의존성 주입이다.  
Spring에서도 ApplicationContext가 Factory에 의존하는 상황에서  
외부 컨테이너에서 의존관계를 주입하는 구조를 가지고 있다.  

팩토리 메소드 패턴에 의존성 주입을 적용해보자.  

DependencyInjectionBefore 패키지에서  
Client A, B, C 클래스가 WhiteShipFactory에 의존하는 상황이다.  
각각을 BlackShipFactory로 바꿀려면, 세 클래스에 가서 한 줄 씩을 고쳐야 한다.  
Dependency injection을 활용해서 결합도를 낮춘다.

1. 주입할 객체의 클래스를 구상 클래스, 주입당하는 객체(참조변수)  
의 클래스를 인터페이스로 바꾼다. 
본 예제에서는 팩토리 메소드 패턴을 적용했기 때문에 이 단계를 생략한다.  
2. 의존성을 주입할 외부의 컨테이너를 만든다. (Container 클래스)  
3. 컨테이너에서 팩토리를 미리 생성한다. (Eager Initialization, 주입할 Source)  
4. 주입 동작을 할 메소드를 구현한다. 반환 타입은 주입 당하는 객체의 타입 (ShipFactory)  
5. Main 클래스에서 컨테이너를 활용해서 주입된 객체를 받는다.  

이상의 과정이 구현된 패키지가 DependencyInjectionAfter  

물론 실제 DI를 구현할 때 위 과정과는 다르다.  
실제로는 컨테이너에서 객체의 수명 관리도 하고, 타입을 자동으로 다 찾아주는 듯 하다.  
https://pmandocom.tistory.com/103  
본 예제는 간단히 그 구조를 모사해 팩토리 메소드 패턴에 적용해본 것이다.  

<br>

## 2. 개방-폐쇄 원칙(Open-Closed Principle)
### 2.1. 의미  
OCP(Open-Closed Principle)란 객체지향 5대 원칙 중 하나로  
어떤 코드 수정 작업을 할 때, 클래스 단위에서  
기존의 코드를 변경하는 것을 지양하고, 확장되는 방향으로  
이루어져야 한다는 것이다.  
### 2.2. 장점  
OCP 를 만족하는 디자인은 클래스 간의 결합도를 낮출 수 있다. (loosely coupled)  
왜냐하면, 수정 작업에서 기존 클래스를 안 건드리기 때문에  
수정에 의한 연쇄 오류가 발생하지 않기 때문이다.  

<br>

## 3. 의존성 주입(Dependency Injection)

<br>

## 4. 다형성(Polymorphism)
